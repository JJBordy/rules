package rules

import (
	"errors"
	"fmt"
	"github.com/JJBordy/rules/rules/core"
	"github.com/JJBordy/rules/rules/functions"
	"github.com/JJBordy/rules/rules/output"
)

type Engine struct {
	conditionChains        map[string]core.ConditionsChain
	ruleSets               map[string][]core.Rule
	conditionFunctions     map[string]functions.Function
	conditionListFunctions map[string]functions.FunctionOfList
}

type EngineConstructorData struct {
	UserFunctions     map[string]functions.Function
	UserListFunctions map[string]functions.FunctionOfList
}

func NewEngine(cd EngineConstructorData) *Engine {
	e := Engine{
		ruleSets: make(map[string][]core.Rule),
	}

	funcs := functions.Default()
	for k, v := range cd.UserFunctions {
		funcs[k] = v
	}

	listFuncs := functions.DefaultOfList()
	for k, v := range cd.UserListFunctions {
		listFuncs[k] = v
	}

	e.conditionFunctions = funcs
	e.conditionListFunctions = listFuncs

	return &e
}

// EvaluateSet - returns the output generated by passing of the input through the set's rules
func (e *Engine) EvaluateSet(setName string, input map[string]interface{}) (map[string]interface{}, error) {

	outputs := make([]map[string]interface{}, 0)

	for _, rule := range e.ruleSets[setName] {
		out, err := rule.GenerateOutput(input)
		if err != nil {
			return nil, err
		}
		if out != nil {
			outputs = append(outputs, out)
		}
	}

	return output.BuildOutput(outputs)
}

// DebugSet - returns the output generated by passing of the input through the set's rules
// also returns a map with all the rule names and the conditions which returned false
// the key of the map map[string][]core.DebugConditions is the rule name, not the rule ID, as the ID is not guaranteed to be there
func (e *Engine) DebugSet(setName string, input map[string]interface{}) (map[string][]core.DebugConditions, map[string]interface{}, error) {
	outputs := make([]map[string]interface{}, 0)
	debugOutput := make(map[string][]core.DebugConditions)

	for _, rule := range e.ruleSets[setName] {

		debugOut, out, err := rule.DebugOutput(input)
		if err != nil {
			return nil, nil, err
		}
		if out != nil {
			outputs = append(outputs, out)
		}
		if debugOut != nil {
			debugOutput[rule.Name] = debugOut
		}
	}

	builtOutput, err := output.BuildOutput(outputs)
	if err != nil {
		return nil, nil, err
	}

	return debugOutput, builtOutput, nil
}

func (e *Engine) CreateSet(setName string, ruleInputs []RuleInput) error {
	parsedRules := make([]core.Rule, 0)

	for _, r := range ruleInputs {
		parsedRule, err := e.parseRuleInput(r)
		if err != nil {
			return err
		}
		parsedRules = append(parsedRules, parsedRule)
	}

	e.ruleSets[setName] = parsedRules

	return nil
}

func (e *Engine) parseRuleInput(ruleInput RuleInput) (core.Rule, error) {
	rule := core.Rule{
		Name:       ruleInput.Name,
		ID:         ruleInput.ID,
		Map:        ruleInput.Map,
		Output:     ruleInput.Output,
		OutputMap:  ruleInput.OutputMap,
		Conditions: make([]core.Condition, 0),
	}

	conditionsChain, err := core.NewConditionChain(ruleInput.ConditionsChain)
	if err != nil {
		return rule, err
	}
	rule.ConditionChain = conditionsChain

	for _, conditionInput := range ruleInput.Conditions {

		inputPath, err := extractConditionInput(conditionInput)
		if err != nil {
			return rule, err
		}

		newCondition := core.NewCondition(fmt.Sprint(inputPath), e.conditionFunctions, e.conditionListFunctions)

		for function, args := range conditionInput {
			err = newCondition.AddFunction(function, args)
			if err != nil {
				return rule, err
			}
		}

		rule.Conditions = append(rule.Conditions, *newCondition)
	}

	return rule, nil
}

// extractConditionInput - extracts input or inputs value, removes it from the map
func extractConditionInput(cond map[string]interface{}) (string, error) {
	if inputPath, ok := cond["input"]; ok {
		delete(cond, "input")
		return fmt.Sprint(inputPath), nil
	}
	if inputListPath, ok := cond["inputs"]; ok {
		delete(cond, "inputs")
		return fmt.Sprint(inputListPath), nil
	}
	return "", errors.New("no input specification in condition")
}
